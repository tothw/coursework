\documentclass[letterpaper,12pt,oneside,onecolumn]{report}
\usepackage{amsmath, amssymb, amstext}
\usepackage{fancyhdr}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\pagestyle{fancy}

\listfiles

\setlength{\hoffset}{0pt}			% 1 inch left margin
\setlength{\oddsidemargin}{0pt}		% 1 inch left margin
\setlength{\voffset}{0pt}			% 1 inch top margin
\setlength{\marginparwidth}{0pt}	% no margin notes
\setlength{\marginparsep}{0pt}		% no margin notes
\setlength{\textwidth}{6.375in}
\raggedbottom

\rhead{William Justin Toth 685 4} %CHANGE n to ASSIGNMENT NUMBER ijk TO COURSE CODE
\renewcommand{\headrulewidth}{0pt}
%\renewcommand{\baselinestretch}{1.2} % 1.2 line spacing for legibility (optional)

\begin{document}
\section*{6.9}
\paragraph{}
Let $E$ be an elliptic curve over $\mathbb{F}_p$ and let $P$ and $Q$ be points in $E(\mathbb{F}_p)$. Suppose that $Q$ is a multiple of $P$ and let $n_0 > 0$ be the smallest solution to $Q = nP$. Let $s > 0$ be the smallest solution to $sP = \infty$. Let $n$ be such that $Q = nP$. By the division algorithm there exists $i, r \in \mathbb{Z}$ such that $n= is + r$, and $0 \leq r < s$. Then $Q = (is + r)P = isP + rP = \infty + rP = rP$.
\paragraph{}
Consider the case $Q = \infty$. Then $\infty = rP$ since $Q = rP$. Now, since $0 \leq r < s$ and $s$ is minimal such that $s>0$ and $sP = \infty$, $r = 0$. Since $Q = n_oP$ and $Q = \infty$, $\infty = n_oP$. Since $n_0, s > 0$ are minimal such that $Q = n_0P$ and $\infty = sP$ respectively, and $Q = \infty$, we have that $n_0 = s$. Now $n = is + r = is + 0 = (i-1)s + s = (i-1)s + n_0$ as desired.
\paragraph{}
Now consider the case $Q \neq \infty$. Then $rP \neq \infty$. Thus $r > 0$, and so $r \geq n_0$ by minimality of $n_0$. Therefore we have $0 < n_0 \leq r < s$. So there exists $0 \leq l < s$, such that $n_0 + l = r$. Then
\begin{align*}
Q &= rP \\
&= (n_0 + l)P \\
&= n_0P + lP \\
&= Q + lP.
\end{align*}
Thus we have $Q = Q + lP$ and so $\infty = lP$. Therefore by the minimality of $s$, $l = 0$. Thus $n_0 = r$, and so $n = is + n_0$ as desired. $\blacksquare$
\section*{6.10}
\paragraph{}
Let $\{P_1, P_2 \}$ be a basis for $E[m]$. Suppose that we have an algorithm $\mathcal{A}$ which can solve the basis problem in polynomial time. Let $P, Q=nP \in E[m]$ be an instance of $ECDLP$. Use $\mathcal{A}$ to compute values $a_1, a_2$ such that $nP = a_1P_1 + a_2P_2$. Now use $\mathcal{A}$ to compute values $b_1, b_2$ such that $P = b_1P_1 + b_2P_2$. Then $nP = nb_1P_1 + nb_2P_2$. Since $\{ P_1, P_2 \}$ are a basis $P_1$ and $P_2$ are independent, and therefore $nb_1 \equiv a_1\ (mod\ m)$ and $nb_2 \equiv b_2\ (mod\ m)$. Since a solution, $n$, exists at least one of these congruences has a solution (both, but we only need one). Say without loss of generality that $nb_1 \equiv a_1\ (mod\ m)$ has a solution. Then $d = gcd(b_1, m) \mid a_1$. Consider the reduced congruence $n\frac{b_1}{d} \equiv \frac{a_1}{d}\ (mod\ \frac{m}{d})$. Solve this congruence finding $d$ solutions $n_1, \dots, n_d$ to $nb_1 \equiv a_1\ (mod\ m)$. Compute $n_1P, \dots, n_dP$ testing for equality with $Q$ to find $n$. Therefore, using $\mathcal{A}$ we have solved $ECDLP$ in polynomial time. $\blacksquare$
\section*{6.16}
\subsection*{a}
\paragraph{}
Let $R = (x_R, y_R) \in E(\mathbb{F}_p)$. Let
\begin{equation*}
\beta_R = \begin{cases}
0 \text{, if $0 \leq y_R < \frac{1}{2}p$}\\
1 \text{, if $\frac{1}{2}p < y_R < p$.}\\
\end{cases}
\end{equation*}
Suppose that Alice can compute square roots modulo $p$ efficiently. We will show that Alice can deduce $y_R$ using only $x_R$ and $\beta_R$. 
\paragraph{}
Suppose that $y^2 = x^3 + ax + b$ is the equation describing the elliptic curve Alice and Bob are using. Alice can compute $y_R^2 = x_R^3 + ax_R + b$. Then $y_R = \pm \sqrt{x_R^3 + ax_R + b}$. Let $y_0 = -\sqrt{x_R^3 + ax_R + b}$ and $y_1 = \sqrt{x_R^3 + ax_R + b}$ be the two possible values for $y_R$. Then $y_0 \equiv -y_1\ (mod\ p)$ and hence $y_0 + y_1 \equiv 0\ (mod\ p)$.
\paragraph{}
We claim that one of $y_0,y_1$ is between $0$ and $\frac{1}{2}p$ and the other is between $\frac{1}{2}p$ and $p$ modulo $p$. In this way Alice can use $\beta_R$ to decide what the intended $y_R$ Bob sent was. To prove this claim, first suppose for a contradiction that $0 \leq y_0,y_1 < \frac{1}{2}p$. They cannot both be $0$ since the solutions are unique. Then $0 < y_0 + y_1 < p$ modulo $p$. Since $p$ is prime, $y_0 + y_1 \nmid p$. But this contradicts that $y_0 + y_1 \equiv 0\ (mod\ p)$.
\paragraph{}
Similarly, suppose for a contradiction that $\frac{1}{2}p < y_0,y_1 < p$ modulo $p$.So  $0 < -y_0 -y_1 < \frac{1}{2}p$ modulo $p$. Since $p$ is prime, $-y_0 - y_1 \nmid p$. But this contradicts that $-y_0 -y_1 \equiv 0\ (mod\ p)$ (which clearly holds since since $y_0 + y_1 \equiv 0\ (mod\ p)$). Therefore one of $y_0,y_1$ is between $0$ and $\frac{1}{2}p$ and the other is between $\frac{1}{2}p$ and $p$ modulo $p$. Therefore Alice can use $\beta_R$ to decide which of $y_0,y_1$ Bob intended as $y_R$. $\blacksquare$
\subsection*{b}
\paragraph{}
Let $p = 1123$. Notice that $p \equiv 3\ (mod\ 4)$. Let $E: Y^2 = X^3 + 54X + 87$ be an elliptic curve group over $\mathbb{F}_p$. Suppose Bob sends Alice $x=278$ and $\beta = 0$. Then $278^3 + 54(278) + 87 = 216$ modulo $1123$. By proposition $2.26$, $y_0 \equiv 216^{(p+1)/4}\ (mod\ p)$ is a square root. Then $y_0 \equiv 487\ (mod 1123)$. Thus $y_1 \equiv -y0 \equiv 636\ (mod\ 1123)$. Now $\frac{1}{2}p = \frac{1}{2}1123 = 561.5$. Since $0 \leq 487 < 561.5$ and $\beta = 0$, Bob was trying to convey that $y_R = 487$, that is the point was $(278, 487)$.
\paragraph{}
Now suppose $\beta = 1$. Then since $561.5 < 636 < 1123$, Bob was trying to convey that $y_R = 636$ in this case. That is the point was $(278, 636)$.
\section*{Fujisaki-Okamoto transform}
\paragraph{}
Note (for academic integrity) that the proofs in this section follow closely the proofs given in the class notes on Fujisaki-Okamoto transform with minor modifications, I do not claim the structure as my own but simply the details needed to accommodate the changes in the full version of the transform.
\paragraph{}
Suppose we have a probabilistic public-key cryptosystem $(\mathcal{G}, \mathcal{E}, \mathcal{D})$ that is \textbf{OW-CPA}, and random oracles $H_1, H_2$. The Fujisaki-Okamoto transform is as described below:
\subparagraph{Key Generation:}
Use $G$.
\subparagraph{Notation:}
$\mathcal{E}$(pubkey,$\sigma;r$) denotes the encryption of the message $\sigma$ resulting from the use of the bitstring $r$ as the source of random bits.
\subparagraph{Encryption:}
Then encryption algorithm is
\begin{align*}
\text{Encrypt(pubkey, }m) = (\mathcal{E}(\text{pubkey, }\sigma;H_2(m,\sigma)), m \oplus H_1(\sigma)),
\end{align*}
 where $\sigma$ is a string chosen at random.
 \subparagraph{Decryption:}
 Given a ciphertext of the form $(c_1,c_2)$, the decryption algorithm computes
 \begin{align*}
 \hat{\sigma} &= \mathcal{D}(\text{privkey},c_1) \\
 \hat{m} &= c_2 \oplus H_1(\hat{\sigma})
 \end{align*}
 and then outputs
 \begin{align*}
 \text{Decrypt(privkey, }(c_1,c_2)) = \begin{cases}
 \hat{m} &\text{if $c_1 = \mathcal{E}$(pubkey,$\hat{\sigma};H_2(\hat{m},\hat{\sigma}))$}\\
 \text{NULL} &\text{otherwise.}
 \end{cases}
 \end{align*}
 \subsection*{Fujisaki-Okamoto transform is IND-CPA}
 \paragraph{}
 Suppose that an algorithm $\mathcal{A}$, given two  messages $m_0$ and $m_1$ of its choice and an encrypted ciphertext ($\mathcal{E}(\text{pubkey, }\sigma;H_2(m_b,\sigma)), m_b \oplus H_1(\sigma)$) of $m_b$, is able to determine the value of $b$. Since $H_1$ and $H_2$ are random oracles, the algorithm $\mathcal{A}$ cannot distinguish between the two distributions:
 \begin{align}
 (\mathcal{E}(\text{pubkey, }\sigma;H_2(m_b,\sigma)), m_b \oplus H_1(\sigma)) : \sigma \text{ chosen at random} \\
 (\mathcal{E}(\text{pubkey, }\sigma;\tau), \mu) : \sigma, \tau, \mu : \text{ chosen at random}
 \end{align}
 unless $\mathcal{A}$ evaluates $H_1(\sigma)$ and $H_2(m_b, \sigma)$. However, since $H_1$ is a random oracle, in order to evaluate $H_1(\sigma)$ the algorithm $\mathcal{A}$ must determine the value of $\sigma$. But then $\mathcal{A}$ can also determine the value of $\sigma$ from the pair $(\mathcal{E}(\text{pubkey, }\sigma;H_2(m_b,\sigma)), m_b \oplus H_1(\sigma))$. But then $\mathcal{A}$ is capable of determining the value of $\sigma$ from the pair $(\mathcal{E}(\text{pubkey, }\sigma;\tau), \mu)$ where $\tau$ and $\mu$ are chosen at random, because distributions $(1)$ and $(2)$ are indistinguishable to $\mathcal{A}$ prior to the determination of $\sigma$. It follows that $\mathcal{A}$ can determine the value of $\sigma$ from $\mathcal{E}(\text{pubkey},\sigma; \tau)$ (for random $\tau$), and hence the original public key cryptosystem $(\mathcal{E}, \mathcal{D})$ was not \textbf{OW-CPA}, contradicting the assumption that the starting cryptosystem is \textbf{OW-CPA}. $\blacksquare$
\subsection*{Fujisaki-Okamoto transform is IND-CCA2}
\paragraph{}
Suppose that an algorithm $\mathcal{A}$, given a decryption oracle $\mathcal{D}$, two messages $m_0$ and $m_1$ of its choice, and an encrypted ciphertext $c = (\mathcal{E}(\text{pubkey, }\sigma;H_2(m_b,\sigma)), m_b \oplus H_1(\sigma)$) of $m_b$, is able to determine the value of $b$ without querying $\mathcal{D}$ on $c$. We will show that, using $\mathcal{A}$, one can construct an alternative algorithm $\mathcal{B}$ which accomplishes the same task without using $\mathcal{D}$.
\paragraph{}
The algorithm $\mathcal{B}$ operates as follows. It runs the algorithm $\mathcal{A}$, and monitors every call that $\mathcal{A}$ makes to the random oracles $H_1$ and $H_2$. Since $H_1$ and $H_2$ are random oracles, there is no way $\mathcal{A}$ can evaluate them on values except by calling them explicitly, so $\mathcal{B}$ can perform this monitoring step reliably. When $\mathcal{B}$ observes $\mathcal{A}$ evaluating $H_2(m,\sigma)$, $\mathcal{B}$ will compute $c = \mathcal{E}(\text{pubkey}, \sigma:H_2(m,\sigma))$ and store in a table $c : (m,\sigma)$ (with the intention of later being able to recognize this ciphertext). Since $H_2$ is deterministic the mapping given by the table is one to one. Whenever $\mathcal{A}$ asks for the decryption of a ciphertext $(c_1,c_2)$, the algorithm $\mathcal{B}$ responds as follows. The algorithm $\mathcal{B}$ checks if $c_1$ is a ciphertext in the table it previously stored. If $c_1$ was previously computed in the table, let $(\hat{m}, \hat{\sigma})$ be the corresponding input that produced $c_1$, and check whether $c_2 = \hat{m} \oplus H_1(\hat{\sigma})$. If this equation holds then output $\hat{m}$, otherwise (or if $c_1$ is not found in the table) output NULL. 
\paragraph{}
We claim that, except with negligible probability, the decryption response provided
\end{document}
